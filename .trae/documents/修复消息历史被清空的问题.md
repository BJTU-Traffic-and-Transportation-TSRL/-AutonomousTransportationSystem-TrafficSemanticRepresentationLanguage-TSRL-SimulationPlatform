## 问题分析

通过分析代码，我发现了问题的根本原因：

1. 在`trafficManager/traffic_manager.py`的`extract_ego_vehicle`方法中，当`through_timestep`大于等于车辆轨迹状态长度时，会触发重新创建自车对象的逻辑
2. 重新创建自车对象时，会调用`init_communication`方法重新初始化通信器
3. 重新初始化通信器会创建新的`VehicleCommunicator`实例，导致原有的消息历史被清空
4. 这就解释了为什么在后续运行中，`message_0_history.txt`文件会被清空，只剩下`SelfVehicle(0);`

## 修复方案

修改`extract_ego_vehicle`方法，确保只有在自车首次出现时才重新初始化通信器，后续更新时保留原有通信器和消息历史：

1. 当自车已存在于`lastseen_vehicles`中但轨迹状态不足时，仍使用原有通信器
2. 避免在更新自车状态时重新初始化通信器
3. 确保消息历史在整个仿真过程中得到保留

## 修复步骤

1. 编辑`trafficManager/traffic_manager.py`文件，修改`extract_ego_vehicle`方法
2. 确保当`through_timestep`大于等于轨迹状态长度时，保留原有通信器
3. 只在自车首次出现时初始化通信器
4. 测试修复效果，确保消息历史不再被清空

## 修复文件
- `trafficManager/traffic_manager.py`：修改`extract_ego_vehicle`方法

这个修复方案将确保HV 0的消息历史在整个仿真过程中得到保留，不会因为车辆状态更新而被清空，从而解决了`message_0_history.txt`文件在后续运行中被清空的问题。